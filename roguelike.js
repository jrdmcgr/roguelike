//@ sourceMappingURL=roguelike.map
// Generated by CoffeeScript 1.6.1
var Actor, Entity, Event, GiantSpider, Item, Map, dude, entities, i, map, mapString, step, tiles, _i,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

mapString = "# # # # # # # # # # # # # # # # # # # # # # # # #\n. . . . . . . . . . . . . . . . . . . . . . . . #\n# # # # # # # # # # # . # # # # # # # # # # # # #\n. . . . . . . . . . # . # . . . . . . . . . . . .\n. . . . . . . . . . # . # . . . . . . . . . . . .\n. . . . . . . . . . # . # . . . . . . . . . . . .\n. . . . . . . . . # # . # # . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . . . . . . . . . . .";

tiles = {
  '#': {
    name: 'brick',
    passable: false,
    fg: '#888',
    bg: '#444',
    action: function() {
      return console.log('Your way is blocked by a brick wall.');
    }
  },
  '.': {
    name: 'ground',
    passable: true,
    fg: '#888'
  },
  undefined: {
    passable: false,
    action: function() {
      return console.log('Your way is blocked by the void.');
    }
  }
};

Map = (function() {

  Map.fromString = function(map) {
    var col, row;
    return new this((function() {
      var _i, _len, _ref, _results;
      _ref = map.split('\n');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = row.split(' ');
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            col = _ref1[_j];
            _results1.push(col);
          }
          return _results1;
        })());
      }
      return _results;
    })());
  };

  function Map(map) {
    this.map = map;
    this.cellSize = 20;
    this.canvas = this.getCanvas();
    this.context = this.canvas.getContext('2d');
  }

  Map.prototype.getCanvas = function() {
    var canvas, currentCanvas;
    currentCanvas = document.getElementsByTagName('canvas');
    if (currentCanvas.length) {
      return currentCanvas[0];
    } else {
      canvas = document.createElement('canvas');
      canvas.height = 500;
      canvas.width = 500;
      document.body.appendChild(canvas);
      return canvas;
    }
  };

  Map.prototype.draw = function() {
    var cell, entity, row, tile, x, y, _i, _j, _k, _len, _len1, _len2, _ref, _results;
    this.context.fillStyle = '#333';
    this.context.fillRect(0, 0, this.canvas.height, this.canvas.width);
    this.context.fillStyle = '#ffefef';
    _ref = this.map;
    for (y = _i = 0, _len = _ref.length; _i < _len; y = ++_i) {
      row = _ref[y];
      for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
        cell = row[x];
        tile = tiles[cell];
        this.drawTile(x, y, cell, tile.fg, tile.bg);
      }
    }
    _results = [];
    for (_k = 0, _len2 = entities.length; _k < _len2; _k++) {
      entity = entities[_k];
      x = entity.location.x;
      y = entity.location.y;
      if (entity.marker) {
        _results.push(this.context.fillText(entity.marker, x * this.cellSize, ++y * this.cellSize));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Map.prototype.drawTile = function(x, y, text, fg, bg) {
    if (fg == null) {
      fg = 'white';
    }
    if (bg == null) {
      bg = 'black';
    }
    this.context.font = '25px Menlo';
    this.context.fillStyle = bg;
    this.context.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
    this.context.fillStyle = fg;
    this.context.fillText(text, x * this.cellSize, ++y * this.cellSize, this.cellSize, this.cellSize);
    return this.context.fillStyle = 'white';
  };

  Map.prototype.clear = function() {
    return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };

  Map.prototype.checkCollision = function(x, y, executeActions) {
    var cell, entity, _ref, _ref1;
    if (executeActions == null) {
      executeActions = false;
    }
    entity = (_ref = _.where(entities, {
      location: {
        x: x,
        y: y
      }
    })) != null ? _ref[0] : void 0;
    cell = tiles[(_ref1 = this.map[y]) != null ? _ref1[x] : void 0];
    if (executeActions) {
      if ((entity != null ? entity.marker : void 0) !== null) {
        if (entity != null) {
          if (typeof entity.action === "function") {
            entity.action();
          }
        }
      }
      if (cell != null) {
        if (typeof cell.action === "function") {
          cell.action();
        }
      }
    }
    return !((cell != null ? cell.passable : void 0) === false || (entity != null ? entity.passable : void 0) === false);
  };

  Map.prototype.inRadius = function(center, radius, point) {
    var x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
    for (y = _i = _ref = center.y - radius, _ref1 = center.y + radius; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
      for (x = _j = _ref2 = center.x - radius, _ref3 = center.x + radius; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
        if (point.x === x && point.y === y) {
          return true;
        }
      }
    }
  };

  return Map;

})();

Entity = (function() {

  function Entity(options) {
    var defaults, key, value;
    defaults = {
      location: {
        x: null,
        y: null
      },
      marker: null,
      name: '',
      passable: true
    };
    _.extend(defaults, options);
    for (key in defaults) {
      value = defaults[key];
      this[key] = value;
    }
    entities.push(this);
  }

  return Entity;

})();

Item = (function(_super) {

  __extends(Item, _super);

  function Item() {
    return Item.__super__.constructor.apply(this, arguments);
  }

  return Item;

})(Entity);

Event = (function(_super) {

  __extends(Event, _super);

  function Event(options) {
    Event.__super__.constructor.call(this, options);
    this.marker = ' ';
  }

  Event.prototype.action = function() {
    console.log(this.name);
    return this.marker = null;
  };

  return Event;

})(Entity);

Actor = (function(_super) {

  __extends(Actor, _super);

  function Actor() {
    return Actor.__super__.constructor.apply(this, arguments);
  }

  Actor.prototype.move = function(x, y) {
    if (map.checkCollision(x, y)) {
      this.location.x = x;
      return this.location.y = y;
    }
  };

  Actor.prototype.randomMovement = function() {
    var x, y;
    x = this.location.x + _.random(-1, 1);
    y = this.location.y + _.random(-1, 1);
    if (map.checkCollision(x, y)) {
      this.location.x = x;
      return this.location.y = y;
    }
  };

  Actor.prototype.moveTowardsDude = function() {
    if (dude.location.x > this.location.x) {
      this.location.x++;
    } else if (dude.location.x < this.location.x) {
      this.location.x--;
    }
    if (dude.location.y < this.location.y) {
      return this.location.y--;
    } else if (dude.location.y > this.location.y) {
      return this.location.y++;
    }
  };

  Actor.prototype.attack = function(location) {
    var entity;
    entity = dude;
    if (entity && entity.health > 0) {
      console.log("" + this.name + " attacks " + entity.name + " for " + this.damage + " points.");
      return entity.health -= this.damage;
    }
  };

  return Actor;

})(Entity);

GiantSpider = (function(_super) {

  __extends(GiantSpider, _super);

  function GiantSpider(options) {
    GiantSpider.__super__.constructor.call(this, options);
    this.marker = 'm';
    this.name = 'giant spider';
    this.passable = false;
    this.health = 30;
    this.damage = 3;
    this.agro = 5;
    this.attackRange = 1;
  }

  GiantSpider.prototype.action = function() {
    if (this.health > 0) {
      return dude.attack(this);
    } else {
      console.log("You killed the " + this.name + ".");
      this.passable = true;
      return this.marker = '%';
    }
  };

  GiantSpider.prototype.behavior = function() {
    if (this.health <= 0) {
      return;
    }
    if (map.inRadius(this.location, this.attackRange, dude.location)) {
      return this.attack(dude.location);
    } else if (map.inRadius(this.location, this.agro, dude.location)) {
      return this.moveTowardsDude(this);
    } else {
      return this.randomMovement(this);
    }
  };

  return GiantSpider;

})(Actor);

entities = [];

new Item({
  location: {
    x: 11,
    y: 3
  },
  marker: 'Â¶',
  name: 'pilcrow of might',
  type: 'weapon',
  rating: 30,
  action: function() {
    console.log("You wield the " + this.name);
    dude.equip(this);
    return this.marker = null;
  }
});

new Event({
  location: {
    x: 11,
    y: 7
  },
  name: "You walk into an open courtyard. In the middle creeps a giant spider!"
});

for (i = _i = 0; _i <= 10; i = ++_i) {
  new GiantSpider({
    location: {
      x: _.random(0, 20),
      y: _.random(8, 20)
    }
  });
}

map = Map.fromString(mapString);

dude = new Actor({
  name: 'dude',
  health: 100,
  armor: {
    name: 'clothes',
    rating: 0
  },
  weapon: {
    name: 'fists',
    rating: 5
  },
  location: {
    x: 1,
    y: 1
  },
  move: function(key) {
    var DOWN, LEFT, RIGHT, UP, x, y;
    LEFT = 37;
    UP = 38;
    RIGHT = 39;
    DOWN = 40;
    x = this.location.x;
    y = this.location.y;
    switch (key) {
      case LEFT:
        x--;
        break;
      case RIGHT:
        x++;
        break;
      case UP:
        y--;
        break;
      case DOWN:
        y++;
    }
    if (map.checkCollision(x, y, true)) {
      this.location.x = x;
      return this.location.y = y;
    }
  },
  equip: function(item) {
    if (item.type === 'armor') {
      this.armor.name = item.name;
      this.armor.rating = item.rating;
      return console.log("Your armor rating is now " + this.armor.rating + ".");
    } else if (item.type === 'weapon') {
      this.weapon.name = item.name;
      this.weapon.rating = item.rating;
      return console.log("Your weapon rating is now " + this.weapon.rating + ".");
    }
  },
  attack: function(entity) {
    var damage;
    damage = this.weapon.rating;
    entity.health -= damage;
    return console.log("You attack the " + entity.name + " for " + damage + " points");
  },
  draw: function() {
    return map.context.fillText('@', this.location.x * map.cellSize, (this.location.y + 1) * map.cellSize);
  }
});

step = function() {
  var robot, robots, _j, _len, _results;
  map.clear();
  map.draw();
  dude.draw();
  robots = _.filter(entities, 'behavior');
  _results = [];
  for (_j = 0, _len = robots.length; _j < _len; _j++) {
    robot = robots[_j];
    _results.push(robot.behavior());
  }
  return _results;
};

$(document).on('keydown', function(e) {
  dude.move(e.which);
  return step();
});

step();
